##### 参考链接：https://juejin.im/post/6844903958624878606#heading-9
## TCP三次握手
1. 客户端向服务端发送一个SYN报文，包含SYN = 1，seq = x；此时客户端处于SYN-send状态；
2. 服务端收到客户端的SYN报文，并更改状态为SYN-RCVD，会回发一个SYN报文，包含标志位SYN=1，ACK =1，和ack = x+1，seq = y；
3. 客户端收到服务端的SYN报文之后，会发送一个ACK报文，包含ACK = 1，ack = y+1；并处于EsTablished状态，当服务器收到ACK报文后，也处于Established状态，此时双方建立连接；

### 为什么需要三次握手，而不是两次
1. 这样无法得知服务端的接收和发送能力是否正常，
2. 如果是两次握手，如果客户端的连接请求由于某些原因，发生了阻塞，而且已经失效后到达了服务端，只要服务端确认后就会建立连接，而客户端会忽略已经失效请求的确认，导致服务端一直等待客户端发送数据，
浪费资源；

### 什么是半连接队列
1. 即服务端收到客户端的SYN报文后，就会处于SYN-recvd状态，服务器会将此种状态放在一个半连接队列里；

### 三次握手过程中可以携带数据吗
1. ACK报文可以携带数据，而SYN报文不可以，所以第一次，第二次握手不可以发送数据，第三次握手可以发送数据，因为，客户端知道了服务器的接收，发送能力是正常的；

### SYN攻击是什么
- 是指客户端在短时间内伪造大量不存在的ip地址，并向服务器不断发送SYN包，Sever则回复确认包，由于ip地址不存在，Server需要不断重发直至超时
，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪；
- 防御SYN攻击：增加最大半连接数，缩短超时时间；过滤网关防护；

## TCP四次挥手
1. C 发送一个FIN报文，包含FIN = 1，seq = u；状态变更为FIN-wait1（终止等待1）状态；
2. S收到C的FIN报文后，会立即发送ACK报文，包含ACK = 1，ack = u+1，seq = v；状态变为close-wait，客户端收到后状态变为FIN-wait2
3. 当服务器数据处理完成后，会发送FIN报文，包含FIN = 1，ACK = 1，ack = u+1,seq = w;并且状态变为LAST-ACK
4. C收到S的FIN报文后，发送一个ACK报文，包含ACK = 1，ack = w+1，seq = u+1；C进入time-wait状态等待2msl后才关闭连接；而S收到C的ACK后立即关闭连接；
 
### 挥手为什么要四次
1. 因为S收到FIN报文时，数据可能并没有处理完成，所以只能发送一个ACK确认报文；待数据处理完成后才发送FIN报文；

### 2MSL等待状态
1. MSL（最长报文段寿命），2倍的原因是确保最后的ACK确认丢失后还能重发一次ACK；

### 释放连接时，wait-time的意义
1. 确保C发送的最后一个ACK报文能够到达S，因为ACK可能会丢失，使得S重新发送FIN+ACK报文段，如果C能在2MSL时间内
收到重传的FIN+ACK报文，说明上一次的ACK丢失，要重新发送ACK报文，并重新计算Time-wait；
2. 防止已经失效的连接请求报文段出现在下一次连接中，因为经过2msl后，此次连接产生的所有报文段都会从网络中消失；
